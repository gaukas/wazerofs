// wraplogfs is a wazero filesystem that wraps another, existing filesystem, and logs
// all inputs/outputs to writer.
//
// Was first generated by hexdigest/gowrap, but then edited for better outputs in some cases
package wraplogfs

import (
	"io"
	"io/fs"
	"log"
	"strings"

	expsys "github.com/tetratelabs/wazero/experimental/sys"
	wasys "github.com/tetratelabs/wazero/sys"
)

type fsWithLog struct {
	// intentionally does NOT embed unimplemented; I do NOT want to be forward-compatible;
	// I want to break on missing funcs

	_stdlog     *log.Logger
	_base       expsys.FS
	_writeBytes bool
}

// New returns a new filesystem on top of another filesystem.
// writeBytes controls if all bytes are written on stdout on reads/writes, or just "(data)".
func New(base expsys.FS, stdout io.Writer, writeBytes bool) expsys.FS {
	return fsWithLog{
		_base:   base,
		_stdlog: log.New(stdout, "", log.LstdFlags),
	}
}

// Chmod implements sys.FS
func (_d fsWithLog) Chmod(path string, perm fs.FileMode) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Chmod with params:", path, perm}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Chmod returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Chmod(path, perm)
}

// Link implements sys.FS
func (_d fsWithLog) Link(oldPath string, newPath string) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Link with params:", oldPath, newPath}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Link returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Link(oldPath, newPath)
}

// Lstat implements sys.FS
func (_d fsWithLog) Lstat(path string) (s1 wasys.Stat_t, e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Lstat with params:", path}
	_d._stdlog.Println(_params...)
	defer func() {
		_d._stdlog.Printf("FSWithLog: Lstat returned results: %+v %s", s1, e1)
	}()
	return _d._base.Lstat(path)
}

// Mkdir implements sys.FS
func (_d fsWithLog) Mkdir(path string, perm fs.FileMode) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Mkdir with params:", path, perm}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Mkdir returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Mkdir(path, perm)
}

func printOflags(flag expsys.Oflag) string {
	st := []string{}
	flags := map[expsys.Oflag]string{

		expsys.O_RDONLY:    "O_RDONLY",
		expsys.O_RDWR:      "O_RDWR",
		expsys.O_WRONLY:    "O_WRONLY",
		expsys.O_APPEND:    "O_APPEND",
		expsys.O_CREAT:     "O_CREAT",
		expsys.O_DIRECTORY: "O_DIRECTORY",
		expsys.O_DSYNC:     "O_DSYNC",
		expsys.O_EXCL:      "O_EXCL",
		expsys.O_NOFOLLOW:  "O_NOFOLLOW",
		expsys.O_NONBLOCK:  "O_NONBLOCK",
		expsys.O_RSYNC:     "O_RSYNC",
		expsys.O_SYNC:      "O_SYNC",
		expsys.O_TRUNC:     "O_TRUNC",
	}
	for f, d := range flags {
		if flag&f != 0 {
			st = append(st, d)
		}
	}
	if len(st) == 0 {
		return "(none)"
	} else {
		return strings.Join(st, "|")
	}
}

// OpenFile implements sys.FS
func (_d fsWithLog) OpenFile(path string, flag expsys.Oflag, perm fs.FileMode) (f1 expsys.File, e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling OpenFile with params:", path, printOflags(flag), perm}
	_d._stdlog.Println(_params...)
	defer func() {
		_d._stdlog.Printf("FSWithLog: OpenFile returned results: %T %+v %s", f1, f1, e1)
	}()
	fl, errno := _d._base.OpenFile(path, flag, perm)
	return fileWithLog{
		_base:       fl,
		_stdlog:     _d._stdlog,
		_writeBytes: _d._writeBytes,
	}, errno
}

// Readlink implements sys.FS
func (_d fsWithLog) Readlink(path string) (s1 string, e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Readlink with params:", path}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Readlink returned results:", s1, e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Readlink(path)
}

// Rename implements sys.FS
func (_d fsWithLog) Rename(from string, to string) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Rename with params:", from, to}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Rename returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Rename(from, to)
}

// Rmdir implements sys.FS
func (_d fsWithLog) Rmdir(path string) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Rmdir with params:", path}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Rmdir returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Rmdir(path)
}

// Stat implements sys.FS
func (_d fsWithLog) Stat(path string) (s1 wasys.Stat_t, e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Stat with params:", path}
	_d._stdlog.Println(_params...)
	defer func() {
		_d._stdlog.Printf("FSWithLog: Stat returned results: %+v %s", s1, e1)
	}()
	return _d._base.Stat(path)
}

// Symlink implements sys.FS
func (_d fsWithLog) Symlink(oldPath string, linkName string) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Symlink with params:", oldPath, linkName}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Symlink returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Symlink(oldPath, linkName)
}

// Unlink implements sys.FS
func (_d fsWithLog) Unlink(path string) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Unlink with params:", path}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Unlink returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Unlink(path)
}

// Utimens implements sys.FS
func (_d fsWithLog) Utimens(path string, atim int64, mtim int64) (e1 expsys.Errno) {
	_params := []interface{}{"FSWithLog: calling Utimens with params:", path, atim, mtim}
	_d._stdlog.Println(_params...)
	defer func() {
		_results := []interface{}{"FSWithLog: Utimens returned results:", e1}
		_d._stdlog.Println(_results...)
	}()
	return _d._base.Utimens(path, atim, mtim)
}
